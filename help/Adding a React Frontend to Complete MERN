Defining the skeleton application frontend

- Home page: A view that renders at the root URL to welcome users to the web application.

- Sign-up page: A view with a form for user sign-up, allowing new users to create a user account and redirecting them to a sign-in page when successfully created.

- Sign-in page: A view with a sign-in form that allows existing users to sign in so they have access to protected views and actions.

- User list page: A view that fetches and shows a list of all the users in the database, and also links to individual user profiles.

- Profile page: A component that fetches and displays an individual user's information. This is only accessible by signed-in users and also contains edit and delete options, which are only visible if the signed-in user is looking at their own profile.

- Edit profile page: A form that fetches the user's information to prefill the form fields. This allows the user to edit the information and this form is accessible only if the logged-in user is trying to edit their own profile. 

- Delete user component: An option that allows the signed-in user to delete their own profile after confirming their intent.

- Menu navigation bar: A component that lists all the available and relevant views to the user, and also helps to indicate the user's current location in the application.

----------------------------------
Setting up for React development

- Before we can start developing with React in our existing skeleton codebase, we need to add configuration to compile and bundle the frontend code, add the React-related dependencies that are necessary to build the interactive interface, and tie this all together in the MERN development flow.

- To achieve this, we will add frontend configuration for Babel, Webpack, and React Hot Loader to compile, bundle, and hot reload the code. Next, we will modify the server code to initiate code bundling for both the frontend and backend in one command to make the development flow simple. Then, we will update the code further so that it serves the bundled code from the server when the application runs in the browser. Finally, we will finish setting up by installing the React dependencies that are necessary to start implementing the frontend.

---------------------------------
Configuring Babel and Webpack

- It is necessary to compile and bundle the React code that we will write to implement the frontend before the code can run in browsers. To compile and bundle the client code so that we can run it during development and also bundle it for production, we will update the configuration for Babel and Webpack. Then, we will configure the Express app to initiate frontend and backend code bundling in one command, so that just starting the server during development gets the complete stack ready for running and testing.

------------
Babel   

- To compile React, first, install the Babel React preset module as a development dependency by running the following command from the command line:
    yarn add --dev @babel/preset-react

- Then, update .babelrc with the following code. This will include the module and also configure the react-hot-loader Babel plugin as required for the react-hot-loader module
    {
        "presets": [
            ["@babel/preset-env",
                {
                    "targets": {
                        "node": "current"
                    }
                }
            ],
            "@babel/preset-react"
        ],
        
        "plugins": [
            "react-hot-loader/babel"
        ]
    }

---------
Webpack

- To bundle client-side code after compiling it with Babel, and also to enable react- hot-loader for faster development, install the following modules by running these commands from the command line:

        yarn add -dev webpack-dev-middleware webpack-hot-middleware file-loader
        yarn add react-hot-loader @hot-loader/react-dom

- Then, to configure Webpack for frontend development and to build the production bundle, we will add a webpack.config.client.js file and a webpack.config.client.production.js file with the same configuration code we described in Chapter 2 , Preparing the Development Environment

-----------
Loading Webpack middleware for development

- During development, when we run the server, the Express app should also load the Webpack middleware that's relevant to the frontend with respect to the configuration that's been set for the client-side code, so that the frontend and backend development workflow is integrated. To enable this, we will use the devBundle.js file we discussed in Chapter 2 , Preparing the Development Environment, in order to set up a compile method that takes the Express app and configures it to use the Webpack middleware. The devBundle.js file in the server folder will look as follows.
- mern-project/server/devBundle.js :

    import config from './../config/config'
    import webpack from 'webpack'
    import webpackMiddleware from 'webpack-dev-middleware'
    import webpackHotMiddleware from 'webpack-hot-middleware'
    import webpackConfig from './../webpack.config.client.js'

    const compile = (app) => {
      if(config.env === "development"){
        const compiler = webpack(webpackConfig)
        const middleware = webpackMiddleware(compiler, {
          publicPath: webpackConfig.output.publicPath
        })
        app.use(middleware)
        app.use(webpackHotMiddleware(compiler))
      }
    }

    export default {
      compile
    }

- In this method, the Webpack middleware uses the values set in webpack.config.client.js , and we enable hot reloading from the server-side using Webpack Hot Middleware.

- Finally, we need to import and call this compile method in express.js by adding the following highlighted lines, but only during development.

- mern-project/server/express.js :

    import devBundle from './devBundle'
    const app = express()
    devBundle.compile(app)

- These two highlighted lines are only meant for development mode and should be commented out when building the code for production. When the Express app runs in development mode, adding this code will import the middleware, along with the client-side Webpack configuration. Then, it will initiate Webpack to compile and bundle the client-side code and also enable hot reloading.

- The bundled code will be placed in the dist folder. This code will be needed to render the views. Next, we will configure the Express server app so that it serves the static files from this dist folder. This will ensure that the bundled React code can be loaded in the browser

---------------------
Loading bundled frontend code

- The frontend views that we will see rendered in the browser will load from the bundled files in the dist folder. For it to be possible to add these bundled files to the HTML view containing our frontend, we need to configure the Express app so that it serves static files, which are files that aren't generated dynamically by server-side code.

-------------------------
Serving static files with Express

- To ensure that the Express server properly handles the requests to static files such as CSS files, images, or the bundled client-side JS, we will configure it so that it serves static files from the dist folder by adding the following configuration in express.js .
- mern-project/server/express.js : 

    import path from 'path'
    const CURRENT_WORKING_DIR = process.cwd()
    app.use('/dist', express.static(path.join(CURRENT_WORKING_DIR, 'dist')))

--------------------------------
Updating the template to load a bundled script

- To add the bundled frontend code in the HTML to render our React frontend, we will update the template.js file so that it adds the script file from the dist folder to the end of the <body> tag.
- mern-project/template.js :

    <body>
        <div id="root"></div>
        <script type="text/javascript" src="/dist/bundle.js"></script>
    </body>

- This script tag will load our React frontend code in the browser when we visit the root URL '/' with the server running. We are ready to see this in action and can start installing the dependencies that will add the React views.

--------------------------
Adding React dependencies

- The frontend views in our skeleton application will primarily be implemented using React. In addition, to enable client-side routing, we will use React Router, and to enhance the user experience with a sleek look and feel, we will use Material-UI. To add these libraries, we will install the following modules in this section:
    + Core React modules: react and react-dom
    + React Router modules: react-router and react-router-dom
    + Material-UI modules: @material-ui/core and @material-ui/icons

------------
React

- Throughout this book, we will use React to code up the frontend. To start writing the React component code, we will need to install the following modules as regular dependencies:

    yarn add react react-dom

- These are the core React library modules that are necessary for implementing the React-based web frontend. With other additional modules, we will add more functionality on top of React.



---------
React Router

- React Router provides a collection of navigational components that enable routing on the frontend for React applications. We will add the following React Router modules:

    yarn add react-router react-router-dom

- These modules will let us utilize declarative routing and have bookmarkable URL routes in the frontend.

-----------------
Material-UI
- In order to keep the UI in our MERN applications sleek without delving too much into UI design and implementation, we will utilize the Material-UI library. It provides ready to use and customizable React components that implement Google's material design. To start using Material-UI components to make the frontend, we need to install the following modules:

    yarn add @material-ui/core @material-ui/icons

- To add the Roboto fonts that are recommended by Material-UI and to use the Material-UI icons, we will add the relevant style links into the template.js file, in the HTML document's <head> section:

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,300,400">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

- With the development configuration all set up and the necessary React modules added to the code base, we can now implement the custom React components, starting with a home page. This should load up as the first view of the complete application.

--------------------
Rendering a home page view

- To demonstrate how to implement a functional frontend for this MERN skeleton, we will start by detailing how to render a simple home page at the root route of the application, before covering backend API integration, user auth integration, and implementing the other view components in the rest of this chapter. 

- The process of implementing and rendering a working Home component at the root route will also expose the basic structure of the frontend code in the skeleton. We will start with the top-level entry component that houses the whole React app and renders the main router component, which links all the React components in the application.

- In the following sections, we will begin implementing the React frontend. First, we will add the root React component, which is integrated with React Router and Material-UI and configured for hot reloading. We will also learn how to customize the Material-UI theme and make the theme available to all our components. Finally, we will implement and load the React component representing the home page, in turn demonstrating how to add and render React views in this application.

----------------
Entry point at main.js

- The client/main.js file in the client folder will be the entry point to render the complete React app, as already indicated in the client-side Webpack configuration object. In client/main.js , we import the root or top-level React component that will contain the whole frontend and render it to the div element with the 'root' ID specified in the HTML document in template.js .

- mern-project/client/main.js :

    import React from 'react'
    import { render } from 'react-dom'
    import App from './App'

    render(<App/>, document.getElementById('root'))

- Here, the top-level root React component is the App component and it is being rendered in the HTML. The App component is defined in client/App.js , as discussed in the next subsection.

-----------------------
Root React component

- The top-level React component that will contain all the components for the application's frontend is defined in the client/App.js file. In this file, we configure the React app so that it renders the view components with a customized Material-UI theme, enables frontend routing, and ensures that the React Hot Loader can instantly load changes as we develop the components.

- In the following sections, we will add code to customize the theme, make this theme and React Router capabilities available to our React components, and configure the root component for hot reloading.

----------------------------
Customizing the Material-UI theme

- The Material-UI theme can be easily customized using the ThemeProvider component. It can also be used to configure the custom values of theme variables in createMuiTheme() . We will define a custom theme for the skeleton application in client/theme.js using createMuiTheme , and then export it so that it can be used in the App component.

- mern-project/client/theme.js :

    import { createMuiTheme } from '@material-ui/core/styles'
    import { pink } from '@material-ui/core/colors'

    const theme = createMuiTheme({
        typography: {
            useNextVariants: true,
        },
        palette: {
            primary: {
            light: '#5c67a3',
            main: '#3f4771',
            dark: '#2e355b',
            contrastText: '#fff',
        },
        secondary: {
            light: '#ff79b0',
            main: '#ff4081',
            dark: '#c60055',
            contrastText: '#000',
        },
            openTitle: '#3f4771',
            protectedTitle: pink['400'],
            type: 'light'
        }
    })

    export default theme

- For the skeleton, we only apply minimal customization by setting some color values to be used in the UI. The theme variables that are generated here will be passed to, and available in, all the components we build

---------------------
Wrapping the root component with ThemeProvider and BrowserRouter

- The custom React components that we will create to make up the user interface will be accessed with the frontend routes specified in the MainRouter component. Essentially, this component houses all the custom views that have been developed for the application and needs to be given the theme values and routing features. This component will be our core component in the root App component, which is defined in the following code.

- mern-skeleton/client/App.js

    import React from 'react'
    import MainRouter from './MainRouter'
    import {BrowserRouter} from 'react-router-dom'
    import { ThemeProvider } from '@material-ui/styles'
    import theme from './theme'

    const App = () => {
        return (
            <BrowserRouter>
                <ThemeProvider theme={theme}>
                    <MainRouter/>
                </ThemeProvider>
            </BrowserRouter>
    )}

- When defining this root component in App.js , we wrap the MainRouter component with ThemeProvider , which gives it access to the Material-UI theme, and BrowserRouter , which enables frontend routing with React Router. The custom theme variables we defined previously are passed as a prop to ThemeProvider , making the theme available in all our custom React components. Finally, in the App.js file, we need to export this App component so that it can be imported and used in main.js .

-----------------------
Marking the root component as hot-exported
- The last line of code in App.js , which exports the App component, uses the higher-order component (HOC) hot module from react-hot-loader to mark the root component as hot

- mern-skeleton/client/App.js :

    import { hot } from 'react-hot-loader'
    const App = () => { ... }
    export default hot(module)(App)

- Marking the App component as hot in this way essentially enables live reloading of our React components during development.

- For our MERN applications, we won't have to change the main.js and App.js code all that much after this point, and we can continue building out the rest of the React app by injecting new components into the MainRouter component, which is what we'll do in the next section.

---------------------------
Adding a home route to MainRouter

- The MainRouter.js code will help render our custom React components with respect to the routes or locations in the application. In this first version, we will only add the root route for rendering the Home component.
- mern-project/client/MainRouter.js :

    import React from 'react'
    import {Route, Switch} from 'react-router-dom'
    import Home from './core/Home'

    const MainRouter = () => {
        return ( 
            <div>
                <Switch>
                    <Route exact path="/" component={Home}/>
                </Switch>
            </div>
        )
    }
    export default MainRouter

- As we develop more view components, we will update the MainRouter and add routes for the new components inside the Switch component.

- The Switch component in React Router renders a route exclusively. In other words, it only renders the first child that matches the requested route path. On the other hand, without being nested in a Switch , every Route component renders inclusively when there is a path match; for example, a request at '/' also matches a route at '/contact' .

- The Home component, which we added this route for in MainRouter , needs to be defined and exported, which we'll do in the next section.

---------------------------
The Home component

---------------------------
Imports
- For each React component implementation, we need to import the libraries, modules, and files being used in the implementation code. The component file will start with imports from React, Material-UI, React Router modules, images, CSS, API fetch, and the auth helpers from our code, as required by the specific component. For example, for the Home component code in Home.js , we use the following imports.

mern-project/client/core/Home.js :

    import React from 'react'
    import { makeStyles } from '@material-ui/core/styles'
    import Card from '@material-ui/core/Card'
    import CardContent from '@material-ui/core/CardContent'
    import CardMedia from '@material-ui/core/CardMedia'
    import Typography from '@material-ui/core/Typography'
    import unicornbikeImg from './../assets/images/unicornbike.jpg'

- The image file is kept in the client/assets/images/ folder and is imported so that it can be added to the Home component. These imports will help us build the component and also define the styles to be used in the component.

-----------------------
Style declarations

- After the imports, we will define the CSS styles that are required to style the elements in the component by utilizing the Material-UI theme variables and makeStyles , which is a custom React hook API provided by Material-UI .

Note: Định nghĩa Hook: Hooks are new to React. Hooks are functions that make it possible to use React state and life cycle features in function components, without having to write a class to define the component. React provides some built-in hooks, but we can also build custom hooks as needed to reuse stateful behavior across different components. To learn more about React Hooks, visit reactjs.org/docs/hooks- intro.html .

mern-project/client/core/Home.js

    const useStyles = makeStyles(theme => ({
        card: {
            maxWidth: 600,
            margin: 'auto',
            marginTop: theme.spacing(5)
        },
        title: {
            padding:`${theme.spacing(3)}px ${theme.spacing(2.5)}px
            ${theme.spacing(2)}px`,
            color: theme.palette.openTitle
        },
        media: {
            minHeight: 400
        }
    }))

- The JSS style objects defined here will be injected into the component using the hook returned by makeStyles . The makeStyles hook API takes a function as an argument and gives access to our custom theme variables, which we can use when defining the styles.

Note JSS: Material-UI uses JSS, which is a CSS-in-JS styling solution for adding styles to components. JSS uses JavaScript as a language to describe styles. This book will not cover CSS and styling implementations in detail. It will mostly rely on the default look and feel of Material-UI components. To learn more about JSS, visit http://cssinjs.​org/​? v=​v9.​8.​1. For examples of how to customize the Material-UI component styles, check out the Material-UI documentation at https:/​/material-​ui.​com.

---------------------
Component definition

- While writing the function to define the component, we will compose the content and behavior of the component. The Home component will contain a Material-UI Card with a headline, an image, and a caption, all styled with the styles we defined previously and returned by calling the useStyles() hook.

mern-project/client/core/Home.js

    export default function Home(){
        const classes = useStyles()
            return (
                <Card className={classes.card}>
                    <Typography variant="h6" className={classes.title}>
                        Home Page
                    </Typography>
                    <CardMedia className={classes.media}
                        image={unicornbikeImg} title="Unicorn Bicycle"/>
                    <CardContent>
                        <Typography variant="body2" component="p">
                            Welcome to the MERN Skeleton home page.
                        </Typography>
                    </CardContent>
                </Card>
            )
    }


Note: Throughout this book, we will define all our React components as functional components. We will utilize React Hooks, which is a new addition to React, to add state and life cycle features, instead of using class definitions to achieve the same. The other view components to be implemented in our MERN applications will adhere to the same structure. In the rest of this book, we will focus mainly on the component definition, highlighting the unique aspects of the implemented component.

- We are almost ready to run this code to render the home page component in the frontend. But before that, we need to update the Webpack configurations so that we can bundle and display images.

--------------------
Bundling image assets

- The static image file that we imported into the Home component view must also be included in the bundle with the rest of the compiled JS code so that the code can access and load it. To enable this, we need to update the Webpack configuration files and add a module rule to load, bundle, and emit image files to the dist output directory, which contains the compiled frontend and backend code.

        yarn add --dev file-loader


-----------------------------
Integrating backend APIs
- Users should be able to use the frontend views to fetch and modify user data in the database based on authentication and authorization. To implement these functionalities, the React components will access the API endpoints that are exposed by the backend using the Fetch API.

Note: The Fetch API is a newer standard that makes network requests similar to XMLHttpRequest (XHR) but using promises instead, enabling a simpler and cleaner API. To learn more about the Fetch API, visit https://developer.mozilla.org/en-US/docs/Web/API/Fetch_​ API .

Fetch for user CRUD

---------------
Creating a user

- The create method will take user data from the view component, which is where we will invoke this method. Then, it will use fetch to make a POST call at the create API route, '/api/users' , to create a new user in the backend with the provided data.

- mern-project/client/user/api-user.js :

    const create = async (user) => {
        try {
            let response = await fetch('/api/users/', {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(user)
            })
        return await response.json()
        } catch(err) {
            console.log(err)
        }
    }

- Finally, in this method, we return the response from the server as a promise. So, the component calling this method can use this promise to handle the response appropriately, depending on what is returned from the server. Similarly, we will implement the list method next.

----------
Listing users
The list method will use fetch to make a GET call to retrieve all the users in the database, and then return the response from the server as a promise to the component.

- mern-project/client/user/api-user.js :

    const list = async (signal) => {
        try {
            let response = await fetch('/api/users/', {
                method: 'GET',
                signal: signal,
            })
            return await response.json()
        } catch(err) {
            console.log(err)
        }
    }

- The returned promise, if it resolves successfully, will give the component an array containing the user objects that were retrieved from the database. In the case of a single user read, we will deal with a single user object instead, as demonstrated next.

----------------
Reading a user profile

-The read method will use fetch to make a GET call to retrieve a specific user by ID. Since this is a protected route, besides passing the user ID as a parameter, the requesting component must also provide valid credentials, which, in this case, will be a valid JWT received after a successful sign-in.

- mern-project/client/user/api-user.js :

    const read = async (params, credentials, signal) => {
        try {
            let response = await fetch('/api/users/' + params.userId, {
                method: 'GET',
                signal: signal,
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + credentials.t
                }
            })
            return await response.json()
        } catch(err) {
            console.log(err)
        }
    }

- The JWT is attached to the GET fetch call in the Authorization header using the Bearer scheme, and then the response from the server is returned to the component in a promise. This promise, when it resolves, will either give the component the user details for the specific user or notify that access is restricted to authenticated users. Similarly, the updated user API method also needs to be passed valid JWT credentials for the fetch call, as shown in the next section.

-----------------------
Updating a user's data

- The update method will take changed user data from the view component for a specific user, then use fetch to make a PUT call to update the existing user in the backend. This is also a protected route that will require a valid JWT as the credential.

- mern-project/client/user/api-user.js :

    const update = async (params, credentials, user) => {
        try {
            let response = await fetch('/api/users/' + params.userId, {
                method: 'PUT',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + credentials.t
                },
                body: JSON.stringify(user)
            })
            return await response.json()
        } catch(err) {
            console.log(err)
        }
    }

- As we have seen with the other fetch calls, this method will also return a promise containing the server's response to the user update request. In the final method, we will learn how to call the user delete API.

---------------
Deleting a user
The remove method will allow the view component to delete a specific user from the database and use fetch to make a DELETE call. This, again, is a protected route that will require a valid JWT as a credential, similar to the read and update methods.

- mern-project/client/user/api-user.js :

    const remove = async (params, credentials) => {
        try {
            let response = await fetch('/api/users/' + params.userId, {
                method: 'DELETE',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + credentials.t
                }
            })
            return await response.json()
        } catch(err) {
            console.log(err)
        }
    }

- The response from the server to the delete request will be returned to the component as a promise, as in the other methods.

- In these five helper methods, we have covered calls to all the user CRUD-related API endpoints that we implemented on the backend. Finally, we can export these methods from the api-user.js file as follows.

- mern-project/client/user/api-user.js :

    export { create, list, read, update, remove }

-These user CRUD methods can now be imported and used by the React components as required. Next, we will implement similar helper methods to integrate the auth- related API endpoints.


----------------
Fetch for the auth API

- In order to integrate the auth API endpoints from the server with the frontend React components, we will add methods for fetching sign-in and sign-out API endpoints in the client/auth/api-auth.js file. Let's take a look at them.

--------------------
Sign-in

- The signin method will take user sign-in data from the view component, then use fetch to make a POST call to verify the user with the backend.

- mern-project/client/auth/api-auth.js :

    const signin = async (user) => {
        try {
            let response = await fetch('/auth/signin/', {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify(user)
            })
            return await response.json()
        } catch(err) {
            console.log(err)
        }
    }

- The response from the server will be returned to the component in a promise, which may provide the JWT if sign-in was successful. The component invoking this method needs to handle the response appropriately, such as storing the received JWT locally so it can be used when making calls to other protected API routes from the frontend. We will look at the implementation for this when we implement the Sign In view later in this chapter.

- After the user is successfully signed in, we also want the option to call the signout API when the user is signing out. The call to the signout API is discussed next.

------------------
Sign-out

- We will add a signout method to api-auth.js , which will use fetch to make a GET call to the signout API endpoint on the server.

- mern-project/client/auth/api-auth.js :

    const signout = async () => {
        try {
            let response = await fetch('/auth/signout/', { method: 'GET' })
            return await response.json()
        } catch(err) {
            console.log(err)
        }
    }

- This method will also return a promise to inform the component about whether the API request was successful.

- At the end of the api-auth.js file, we will export the signin and signout
methods.
    
    export { signin, signout }

- Now, these methods can be imported into the relevant React components so that we can implement the user sign-in and signout features. 

- With these API fetch methods added, the React frontend has complete access to the endpoints we made available in the backend. Before we start putting these methods to use in our React components, we will look into how user auth state can be maintained across the frontend.


----------------------
Adding auth in the frontend

- As we discussed in the previous chapter, implementing authentication with JWT relinquishes responsibility to the client-side to manage and store user auth state. To this end, we need to write code that will allow the client-side to store the JWT that's received from the server on successful sign-in, make it available when accessing protected routes, delete or invalidate the token when the user signs out, and also restrict access to views and components on the frontend based on the user auth state.

- Using examples of the auth workflow from the "React Router documentation", in the following sections, we will write helper methods to manage the auth state across the components, and also use a custom PrivateRoute component to add protected routes to the frontend of the MERN skeleton application.

-------------
Managing auth state

- To manage auth state in the frontend of the application, the frontend needs to be able to store, retrieve, and delete the auth credentials that are received from the server on successful user sign in. In our MERN applications, we will use the browser's sessionsStorage as the storage option to store the JWT auth credentials.

- Alternatively, you can use localStorage instead of sessionStorage to store the JWT credentials. With sessionStorage , the user auth state will only be remembered in the current window tab. With localStorage , the user auth state will be remembered across tabs in a browser. 

- In client/auth/auth-helper.js , we will define the helper methods discussed in the following sections to store and retrieve JWT credentials from client-side sessionStorage , and also clear out the sessionStorage on user sign-out.

--------------
Saving credentials

- In order to save the JWT credentials that are received from the server on successful sign-in, we use the authenticate method, which is defined as follows.

- mern-project/client/auth/auth-helper.js :

    authenticate(jwt, cb); {
        if(typeof window !== "undefined")
            sessionStorage.setItem('jwt', JSON.stringify(jwt))
        cb()
    }

- The authenticate method takes the JWT credentials, jwt , and a callback function, cb , as arguments. It stores the credentials in sessionStorage after ensuring window is defined, in other words ensuring this code is running in a browser and hence has access to sessionStorage . Then, it executes the callback function that is passed in. This callback will allow the component – in our case, the component where sign-in is called – to define actions that should take place after successfully signing in and storing credentials. Next, we will discuss the method that lets us access these stored credentials.

----------------
Retrieving credentials

- In our frontend components, we will need to retrieve the stored credentials to check if the current user is signed in. In the isAuthenticated() method, we can retrieve these credentials from sessionStorage.

- mern-project/client/auth/auth-helper.js :

    isAuthenticated(); {
        if (typeof window == "undefined")
            return false

        if (sessionStorage.getItem('jwt'))
            return JSON.parse(sessionStorage.getItem('jwt'))
        else
            return false
    }

- A call to isAuthenticated() will return either the stored credentials or false , depending on whether credentials were found in sessionStorage . Finding credentials in storage will mean a user is signed in, whereas not finding credentials will mean the user is not signed in. We will also add a method that allows us to delete the credentials from storage when a signed-in user signs out from the application.

----------------
Deleting credentials

- When a user successfully signs out from the application, we want to clear the stored JWT credentials from sessionStorage . This can be accomplished by calling the clearJWT method, which is defined in the following code.

- mern-project/client/auth/auth-helper.js

    clearJWT(cb); {
        if(typeof window !== "undefined")
            sessionStorage.removeItem('jwt')
        cb()
        signout().then((data) => {
            document.cookie = "t=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;"
        })
    }

- This clearJWT method takes a callback function as an argument, and it removes the JWT credential from sessionStorage . The passed in cb() function allows the component initiating the signout functionality to dictate what should happen after a successful sign-out.

- The clearJWT method also uses the signout method we defined earlier in api-auth.js to call the signout API in the backend. If we had used cookies to store the credentials instead of sessionStorage , the response to this API call would be where we clear the cookie, as shown in the preceding code. Using the signout API call is optional since this is dependent on whether cookies are used as the credential storage mechanism.

- With these three methods, we now have ways of storing, retrieving, and deleting JWT credentials on the client-side. Using these methods, the React components we build for the frontend will be able to check and manage user auth state to restrict access in the frontend, as demonstrated in the following section with the custom PrivateRoute component.

-----------------------
The PrivateRoute component

- The code in the file defines the PrivateRoute component, as shown in the auth flow example at https://reacttraining.com/react-router/web/example/auth-workflow , which can be found in the React Router documentation. It will allow us to declare protected routes for the frontend to restrict view access based on user auth.

- mern-project/client/auth/PrivateRoute.js :

    import React, { Component } from 'react'
    import { Route, Redirect } from 'react-router-dom'
    import auth from './auth-helper'

    const PrivateRoute = ({ component: Component, ...rest }) => (
        <Route {...rest} render={props => (
            auth.isAuthenticated() ? (
            <Component {...props}/>
            ) : (
                <Redirect to={{
                        pathname: '/signin',
                        state: { from: props.location }
                }}/>
            )
        )}/>
    )

    export default PrivateRoute

- Components to be rendered in this PrivateRoute will only load when the user is authenticated, which is determined by a call to the isAuthenticated method; otherwise, the user will be redirected to the Signin component. We load the components that should have restricted access, such as the user profile component, in a PrivateRoute . This will ensure that only authenticated users are able to view the user profile page.

- With the backend APIs integrated and the auth management helper methods ready for use in the components, we can now start building the remaining view components that utilize these methods and complete the frontend.

------------------
Completing the User frontend

- The React components that will be described in this section complete the interactive features we defined for the skeleton by allowing users to view, create, and modify user data stored in the database with respect to auth restrictions. The components we will implement are as follows:

    * Users : To fetch and list all users from the database to the view
    * Signup : To display a form that allows new users to sign up
    * Signin : To display a form that allows existing users to sign in
    * Profile : To display details for a specific user after retrieving from the database
    * EditProfile : To display details for a specific user and allow authorized user to update these details
    * DeleteUser : To allow an authorized user to delete their account from the application
    * Menu : To add a common navigation bar to each view in the application 

---------------------
The Users component

- The Users component in client/user/Users.js shows the names of all the users that have been fetched from the database and links each name to the user profile. The following component can be viewed by any visitor to the application and will render at the '/users' route:

- mern-project/client/user/Users.js :

    export default function Users() {
        ....
        const [users, setUsers] = useState([])
        ....
    }

- In the component definition, similar to how we implemented the Home component, we define and export a function component. In this component, we start by initializing the state with an empty array of users.

- We are using the built-in React hook, useState , to add state to this function component. By calling this hook, we are essentially declaring a state variable named users , which can be updated by invoking setUsers , and also set the initial value of users to [ ] .

- Using the built-in useState hook allows us to add state behavior to a function component in React. Calling it will declare a state variable, similar to using this.state in class component definitions. The argument that's passed to useState is the initial value of this variable – in other words, the initial state. Invoking useState returns the current state and a function that updates the state value, which
is similar to this.setState in a class definition.

- With the users state initialized, next, we will use another built-in React hook named useEffect to fetch a list of users from the backend and update the users value in the state.

**Note: The Effect Hook, useEffect , serves the purpose of the componentDidMount , componentDidUpdate , and componentWillUnmount React life cycle methods that we would otherwise use in React classes. Using this hook in a function component allows us to perform side effects such as fetching data from a backend. By default, React runs the effects defined with useEffect after every render, including the first render. But we can also instruct the effect to only rerun if something changes in state. Optionally, we can also define how to clean up after an effect, for example, to perform an action such as aborting a fetch signal when the component unmounts to avoid memory leaks.

- In our Users component, we use useEffect to call the list method from the api-user.js helper methods. This will fetch the user list from the backend and load the user data into the component by updating the state.

- mern-skeleton/client/user/Users.js

    useEffect(() => {
    
        const abortController = new AbortController()
        const signal = abortController.signal
    
        list(signal).then((data) => {
            if (data && data.error) {
                console.log(data.error)
            } else {
                setUsers(data)
            }
        })
        return function cleanup(){
            abortController.abort()
        }
    
    }, [])

- In this effect, we also add a cleanup function to abort the fetch call when the component unmounts. To associate a signal with the fetch call, we use the AbortController web API, which allows us to abort DOM requests as needed.

- In the second argument of this useEffect hook, we pass an empty array so that this effect cleanup runs only once upon mounting and unmounting, and not after every render.

- Finally, in the return of the Users function component, we add the actual view content. The view is composed of Material-UI components such as Paper , List , and ListItem . These elements are styled with the CSS that is defined and made available with the makeStyles hook, the same way as in the Home component.

- mern-project/client/user/Users.js :

    return (
        <Paper className={classes.root} elevation={4}>
            <Typography variant="h6" className={classes.title}>
                All Users
            </Typography>
            <List dense>
                {users.map((item, i) => {
                    return <Link to={"/user/" + item._id} key={i}>
                        <ListItem button>
                            <ListItemAvatar>
                                <Avatar>
                                    <Person/>
                                </Avatar>
                            </ListItemAvatar>
                            <ListItemText primary={item.name}/>
                            <ListItemSecondaryAction>
                                <IconButton>
                                    <ArrowForward/>
                                </IconButton>
                            </ListItemSecondaryAction>
                        </ListItem>
                    </Link>
                })
                }
            </List>
        </Paper>
    )

- In this view, to generate each list item, we iterate through the array of users in the state using the map function. A list item is rendered with an individual user's name from each item that's accessed per iteration on the users array.

- To add this Users component to the React application, we need to update the MainRouter component with a Route that renders this component at the '/users' path. Add the Route inside the Switch component after the Home route.

- mern-project/client/MainRouter.js :

    <Route path="/users" component={Users}/>

- To see this view rendered in the browser, you can temporarily add a Link component to the Home component to be able to route to the Users component:

    <Link to="/users">Users</Link>

---------------------
The Signup component

- The Signup component in client/user/Signup.js presents a form with name, email, and password fields to the user for sign-up at the '/signup' path.


